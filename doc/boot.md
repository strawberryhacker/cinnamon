# Boot sequence

The CPU allways boots from ROM at memory address 0x00000000. The ROM code contains the FSB (first stage bootloader). The ROM code is responsible for loading either an application or a SBL (second stage bootloader) into memory and start executing it. The boot sequence is controlled by a boot configuration word in the fuse area, page 130. The ROM code loads c-boot from an MMC device into memory at address 0x00200000. During startup c-boot remapps this address space to 0x00000000. This way the vector table at 0x00200000 can be accessed at address 0x00000000. This allows interrupts to be used in the bootloader. 

The main responsibility for the bootloader is to initialize external memories and load the kernel. Currently the kernel can only be loaded from a script over a COM port. c-boot will load the kernel binry into the beginning of external DDR memory. It then set up some kernel parameters describing the memory map (size and start address) and relocates this table at the end of the kernel space in DDR. It knows how big the kernel is by examining the first word in the kernel binary. It has to do this in order to account for any (NOLOAD) sections in the kernel. 

The kernel is then called from external DDR. The important fact is that the kernel is linked in virtual memory at address 0xC0000000 and loaded to physical address 0x20000000. In order to run any non PIC code from the kernel the boot code must setup an initial page table. The kernel boot sequence is divided into two parts.

The first part sets up an initial page allocated in the linker. This code is position independent. This means it can be loaded anywhere in physical memory provided that the address is visible though register r0. The initial page table is alligned with 1024 bytes and placed last in kernel memory. This is because then it can be overwritten when the allocators are enabled later. So; linker provedes a 4k section for the initial page table. The boot code is position independent and configures this page table. Two main mappings will be done; the kernel logcial to physical (0xC000000 -> KERNEL_LOAD_ADDR) and the 1:1 identity mapping (KERNEL_LOAD_ADDR -> KERNEL_LOAD_ADDR). The latter solves any pipeline issues when enabling the MMU. After the MMU is enabled the stacks are reconfigured using kernel logical addresses. The bss segment is cleared and the CPU jumps to cinnamon_entry. *Note that 3 1M PT mappings are done temporarily in order to support printf before the kernel PT is enabled*
